import crypto
import core

module Blockchain

// Wallet Management

/** 
 * Creates a new wallet with private key and address.
 */
define function createWallet() : Map
begin
    // Generate a real cryptographic key pair
    var keys = Crypto.generateKeyPair("rsa")
    var privateKey = keys["private"]
    var publicKey = keys["public"]
    
    // Derive address from public key (last 20 bytes of keccak256)
    var address = Crypto.publicKeyToAddress(publicKey)
    
    return {
        "privateKey": privateKey,
        "publicKey": publicKey,
        "address": address
    }
end

/** 
 * Imports a wallet from a private key (PEM).
 */
define function importWallet(privateKey: String) : Map
begin
    // Derive real public key from private key PEM
    var publicKey = Sys.getPublicKey(privateKey)
    var address = Crypto.publicKeyToAddress(publicKey)
    
    return {
        "privateKey": privateKey,
        "publicKey": publicKey,
        "address": address
    }
end

/** 
 * Returns the address of a wallet.
 */
define function getAddress(wallet: Map) : String
begin
    return wallet["address"]
end

/** 
 * Signs a message with a wallet's private key.
 */
define function signMessage(wallet: Map, message: String) : String
begin
    var privateKey = wallet["privateKey"]
    return Crypto.sign(message, privateKey)
end

/** 
 * Verifies a signature.
 */
define function verifySignature(message: String, signature: String, address: String) : Bool
begin
    // Simplified verification
    return Crypto.verify(message, signature, address)
end

// Transaction Management

/** 
 * Creates a transaction.
 */
define function createTransaction(sender: String, recipient: String, amount: Integer, nonce: Integer) : Map
begin
    return {
        "from": sender,
        "to": recipient,
        "amount": amount,
        "nonce": nonce,
        "timestamp": Sys.now(),
        "signature": ""
    }
end

/** 
 * Signs a transaction.
 */
/**
 * Calculates the hash of a transaction.
 */
define function calculateTransactionHash(tx: Map) : String
begin
    var txData = tx["from"] + tx["to"] + str(tx["amount"]) + str(tx["nonce"])
    return Crypto.sha256(txData)
end

/** 
 * Signs a transaction.
 */
define function signTransaction(wallet: Map, tx: Map) : Map
begin
    // Create transaction hash
    var txHash = calculateTransactionHash(tx)
    
    // Sign the hash
    var signature = signMessage(wallet, txHash)
    
    // Add signature to transaction
    tx["signature"] = signature
    tx["hash"] = txHash
    
    return tx
end

// Block Management

/**
 * Calculates the combined hash of a list of transactions.
 */
define function calculateTransactionsHash(transactions: Array) : String
begin
    var txHashes = ""
    for each tx in transactions do
        txHashes = txHashes + tx["hash"]
    end for
    return Crypto.sha256(txHashes)
end

/** 
 * Creates a new block.
 */
define function createBlock(index: Integer, previousHash: String, transactions: Array) : Map
begin
    var timestamp = Sys.now()
    var transactionsHash = calculateTransactionsHash(transactions)
    
    // Create block
    var block = {
        "index": index,
        "timestamp": timestamp,
        "previousHash": previousHash,
        "transactionsHash": transactionsHash,
        "transactions": transactions,
        "nonce": 0,
        "hash": ""
    }
    
    return block
end

/** 
 * Calculates block hash.
 */
define function calculateBlockHash(block: Map) : String
begin
    var data = str(block["index"]) + 
               str(block["timestamp"]) + 
               block["previousHash"] + 
               block["transactionsHash"] + 
               str(block["nonce"])
    
    return Crypto.sha256(data)
end

/** 
 * Internal helper: check if string starts with prefix
 */
define function startsWith(s: String, prefix: String) : Bool
begin
    var len = String.length(prefix)
    if String.length(s) < len then return false end if
    return String.slice(s, 0, len) == prefix
end

/** 
 * Internal helper: repeat string
 */
define function repeatString(s: String, count: Integer) : String
begin
    var res = ""
    var i = 0
    while i < count do
        res = res + s
        i = i + 1
    end while
    return res
end

/** 
 * Mines a block (simplified Proof of Work).
 */
define function mineBlock(block: Map, difficulty: Integer) : Map
begin
    var target = repeatString("0", difficulty)
    var nonce = 0
    var hash = ""
    
    // Simple mining loop (limited iterations for demo)
    var maxIterations = 100000
    var iterations = 0
    
    while iterations < maxIterations do
        block["nonce"] = nonce
        hash = calculateBlockHash(block)
        
        // Check if hash meets difficulty (starts with target)
        if startsWith(hash, target) then
            block["hash"] = hash
            return block
        end if
        
        nonce = nonce + 1
        iterations = iterations + 1
    end while
    
    // If we didn't find a valid hash, just use the last one
    block["hash"] = hash
    return block
end

/** 
 * Validates a block.
 */
define function validateBlock(block: Map, previousBlock: Map) : Bool
begin
    // Check index
    if block["index"] != previousBlock["index"] + 1 then
        return false
    end if
    
    // Check previous hash
    if block["previousHash"] != previousBlock["hash"] then
        return false
    end if
    
    // Verify each transaction's integrity
    for each tx in block["transactions"] do
        if tx["hash"] != calculateTransactionHash(tx) then
            return false
        end if
    end for

    // Verify transactions list hash
    var currentTxsHash = calculateTransactionsHash(block["transactions"])
    if block["transactionsHash"] != currentTxsHash then
        return false
    end if

    // Recalculate and verify block hash
    var calculatedHash = calculateBlockHash(block)
    if block["hash"] != calculatedHash then
        return false
    end if
    
    return true
end

// Blockchain Management

/** 
 * Creates a genesis block.
 */
define function createGenesisBlock() : Map
begin
    var genesisBlock = createBlock(0, "0", [])
    genesisBlock["hash"] = calculateBlockHash(genesisBlock)
    return genesisBlock
end

/** 
 * Creates a new blockchain.
 */
define function createBlockchain() : Map
begin
    var genesis = createGenesisBlock()
    
    return {
        "blocks": [genesis],
        "pendingTransactions": [],
        "difficulty": 4,
        "miningReward": 100
    }
end

/** 
 * Adds a block to the blockchain.
 */
define function addBlock(blockchain: Map, block: Map) : Bool
begin
    var chain = blockchain["blocks"]
    var lastBlock = chain[List.length(chain) - 1]
    
    if validateBlock(block, lastBlock) then
        List.append(chain, block)
        return true
    end if
    
    return false
end

/** 
 * Gets the latest block.
 */
define function getLatestBlock(blockchain: Map) : Map
begin
    var chain = blockchain["blocks"]
    return chain[List.length(chain) - 1]
end

/** 
 * Validates the entire blockchain.
 */
define function validateChain(blockchain: Map) : Bool
begin
    var chain = blockchain["blocks"]
    var chainLength = List.length(chain)
    
    // Start from index 1 (skip genesis)
    var i = 1
    while i < chainLength do
        var currentBlock = chain[i]
        var previousBlock = chain[i - 1]
        
        if not validateBlock(currentBlock, previousBlock) then
            return false
        end if
        
        i = i + 1
    end while
    
    return true
end

/** 
 * Validates an address format.
 */
define function isValidAddress(address: String) : Bool
begin
    if not startsWith(address, "0x") then 
        return false 
    end if
    
    return String.length(address) == 42
end


/**
 * Validates a transaction.
 */
define function validateTransaction(tx: Map) : Bool
begin
    // Check if amount is positive
    if tx["amount"] <= 0 then
        return false
    end if
    
    // Check if sender/recipient exist (simplified check)
    if String.length(tx["sender"]) == 0 or String.length(tx["recipient"]) == 0 then
        return false
    end if
    
    return true
end

end module
