import crypto
import core

module Blockchain

// Wallet Management

/** 
 * Creates a new wallet with private key and address.
 */
define function createWallet() : Map
begin
    // Generate a random private key (32 bytes)
    var privateKeyBytes = Crypto.randomBytes(32)
    var privateKey = Crypto.hexEncode(privateKeyBytes)
    
    // Derive public key (simplified - using hash of private key)
    var publicKey = Crypto.sha256(privateKey)
    
    // Derive address from public key (last 20 bytes of keccak256)
    var address = Crypto.publicKeyToAddress(publicKey)
    
    return {
        "privateKey": privateKey,
        "publicKey": publicKey,
        "address": address
    }
end

/** 
 * Imports a wallet from a private key.
 */
define function importWallet(privateKey: String) : Map
begin
    // Derive public key from private key
    var publicKey = Crypto.sha256(privateKey)
    
    // Derive address
    var address = Crypto.publicKeyToAddress(publicKey)
    
    return {
        "privateKey": privateKey,
        "publicKey": publicKey,
        "address": address
    }
end

/** 
 * Returns the address of a wallet.
 */
define function getAddress(wallet: Map) : String
begin
    return wallet["address"]
end

/** 
 * Signs a message with a wallet's private key.
 */
define function signMessage(wallet: Map, message: String) : String
begin
    var privateKey = wallet["privateKey"]
    return Crypto.sign(message, privateKey)
end

/** 
 * Verifies a signature.
 */
define function verifySignature(message: String, signature: String, address: String) : Bool
begin
    // Simplified verification
    return Crypto.verify(message, signature, address)
end

// Transaction Management

/** 
 * Creates a transaction.
 */
define function createTransaction(sender: String, recipient: String, amount: Integer, nonce: Integer) : Map
begin
    return {
        "from": sender,
        "to": recipient,
        "amount": amount,
        "nonce": nonce,
        "timestamp": 0,  // Would use Time.now() in production
        "signature": ""
    }
end

/** 
 * Signs a transaction.
 */
define function signTransaction(wallet: Map, tx: Map) : Map
begin
    // Create transaction hash
    var txData = tx["from"] + tx["to"] + str(tx["amount"]) + str(tx["nonce"])
    var txHash = Crypto.sha256(txData)
    
    // Sign the hash
    var signature = signMessage(wallet, txHash)
    
    // Add signature to transaction
    tx["signature"] = signature
    tx["hash"] = txHash
    
    return tx
end

// Block Management

/** 
 * Creates a new block.
 */
define function createBlock(index: Integer, previousHash: String, transactions: Array) : Map
begin
    var timestamp = 0  // Would use Time.now()
    
    // Calculate transactions hash
    var txHashes = ""
    for each tx in transactions do
        txHashes = txHashes + tx["hash"]
    end for
    
    var transactionsHash = Crypto.sha256(txHashes)
    
    // Create block
    var block = {
        "index": index,
        "timestamp": timestamp,
        "previousHash": previousHash,
        "transactionsHash": transactionsHash,
        "transactions": transactions,
        "nonce": 0,
        "hash": ""
    }
    
    return block
end

/** 
 * Calculates block hash.
 */
define function calculateBlockHash(block: Map) : String
begin
    var data = str(block["index"]) + 
               str(block["timestamp"]) + 
               block["previousHash"] + 
               block["transactionsHash"] + 
               str(block["nonce"])
    
    return Crypto.sha256(data)
end

/** 
 * Internal helper: check if string starts with prefix
 */
define function startsWith(s: String, prefix: String) : Bool
begin
    var len = String.length(prefix)
    if String.length(s) < len then return false end if
    return String.slice(s, 0, len) == prefix
end

/** 
 * Internal helper: repeat string
 */
define function repeatString(s: String, count: Integer) : String
begin
    var res = ""
    var i = 0
    while i < count do
        res = res + s
        i = i + 1
    end while
    return res
end

/** 
 * Mines a block (simplified Proof of Work).
 */
define function mineBlock(block: Map, difficulty: Integer) : Map
begin
    var target = repeatString("0", difficulty)
    var nonce = 0
    var hash = ""
    
    // Simple mining loop (limited iterations for demo)
    var maxIterations = 100000
    var iterations = 0
    
    while iterations < maxIterations do
        block["nonce"] = nonce
        hash = calculateBlockHash(block)
        
        // Check if hash meets difficulty (starts with target)
        if startsWith(hash, target) then
            block["hash"] = hash
            return block
        end if
        
        nonce = nonce + 1
        iterations = iterations + 1
    end while
    
    // If we didn't find a valid hash, just use the last one
    block["hash"] = hash
    return block
end

/** 
 * Validates a block.
 */
define function validateBlock(block: Map, previousBlock: Map) : Bool
begin
    // Check index
    if block["index"] != previousBlock["index"] + 1 then
        return false
    end if
    
    // Check previous hash
    if block["previousHash"] != previousBlock["hash"] then
        return false
    end if
    
    // Recalculate and verify hash
    var calculatedHash = calculateBlockHash(block)
    if block["hash"] != calculatedHash then
        return false
    end if
    
    return true
end

// Blockchain Management

/** 
 * Creates a genesis block.
 */
define function createGenesisBlock() : Map
begin
    var genesisBlock = createBlock(0, "0", [])
    genesisBlock["hash"] = calculateBlockHash(genesisBlock)
    return genesisBlock
end

/** 
 * Creates a new blockchain.
 */
define function createBlockchain() : Map
begin
    var genesis = createGenesisBlock()
    
    return {
        "chain": [genesis],
        "pendingTransactions": [],
        "difficulty": 4,
        "miningReward": 100
    }
end

/** 
 * Adds a block to the blockchain.
 */
define function addBlock(blockchain: Map, block: Map) : Bool
begin
    var chain = blockchain["chain"]
    var lastBlock = chain[List.length(chain) - 1]
    
    if validateBlock(block, lastBlock) then
        List.append(chain, block)
        return true
    end if
    
    return false
end

/** 
 * Gets the latest block.
 */
define function getLatestBlock(blockchain: Map) : Map
begin
    var chain = blockchain["chain"]
    return chain[List.length(chain) - 1]
end

/** 
 * Validates the entire blockchain.
 */
define function validateChain(blockchain: Map) : Bool
begin
    var chain = blockchain["chain"]
    var chainLength = List.length(chain)
    
    // Start from index 1 (skip genesis)
    var i = 1
    while i < chainLength do
        var currentBlock = chain[i]
        var previousBlock = chain[i - 1]
        
        if not validateBlock(currentBlock, previousBlock) then
            return false
        end if
        
        i = i + 1
    end while
    
    return true
end

/** 
 * Validates an address format.
 */
define function isValidAddress(address: String) : Bool
begin
    if not startsWith(address, "0x") then 
        return false 
    end if
    
    return String.length(address) == 42
end

end module
